

use anyhow::{anyhow, Result}; use base64::{engine::general_purpose::STANDARD, Engine}; use chacha20poly1305::{aead::{Aead, KeyInit}, ChaCha20Poly1305, Key, Nonce}; use ed25519_dalek::{Signature, Verifier, VerifyingKey}; use hkdf::Hkdf; use libp2p::{ core::upgrade, identity::Keypair, mdns, noise, ping, request_response::{self, ProtocolSupport}, swarm::{NetworkBehaviour, SwarmEvent}, tcp, yamux, PeerId, Swarm, }; use prost::Message; use rand::{rngs::OsRng, RngCore}; use sha2::{Digest, Sha256}; use sled::Db; use std::{ collections::{HashMap, VecDeque}, path::PathBuf, sync::Arc, time::{Duration, Instant}, }; use tokio::{sync::{RwLock, Semaphore}, time::timeout}; use wasmtime::*; use x25519_dalek::{PublicKey, StaticSecret}; /* ================= LIMITS ================= */ const MAX_OUTPUT: usize = 1 << 20; const MAX_FUEL: u64 = 10_000_000; const TASK_TIMEOUT: Duration = Duration::from_secs(3); const REPLAY_TTL: Duration = Duration::from_secs(120); const REPLAY_MAX: usize = 4096; const BAN_AFTER: u32 = 3; const BAN_TIME: Duration = Duration::from_secs(300); /* ================= ABI ================= */ #[derive(Clone, PartialEq, Message)] pub struct TaskEnvelope { #[prost(bytes, tag="1")] pub task_id: Vec<u8>, #[prost(bytes, tag="2")] pub encrypted_payload: Vec<u8>, #[prost(bytes, tag="3")] pub sender_ed25519: Vec<u8>, #[prost(bytes, tag="4")] pub sender_x25519: Vec<u8>, #[prost(bytes, tag="5")] pub nonce: Vec<u8>, #[prost(bytes, tag="6")] pub signature: Vec<u8>, } #[derive(Clone, PartialEq, Message)] pub struct TaskPayload { #[prost(string, tag="1")] pub wasm_base64: String, #[prost(string, tag="2")] pub wasm_hash: String, #[prost(string, tag="3")] pub args_json: String, #[prost(uint32, tag="4")] pub max_fuel: u32, } #[derive(Clone, PartialEq, Message)] pub struct TaskResult { #[prost(bytes, tag="1")] pub task_id: Vec<u8>, #[prost(string, tag="2")] pub result_json: String, #[prost(int32, tag="3")] pub exit_code: i32, } /* ================= NETWORK ================= */ #[derive(NetworkBehaviour)] #[behaviour(out_event = "Event")] struct Behaviour { reqres: request_response::Behaviour<TaskCodec>, mdns: mdns::tokio::Behaviour, ping: ping::Behaviour, } enum Event { ReqRes(request_response::Event<TaskEnvelope, TaskResult>), Mdns(mdns::Event), Ping(ping::Event), } impl From<request_response::Event<TaskEnvelope, TaskResult>> for Event { fn from(e: request_response::Event<TaskEnvelope, TaskResult>) -> Self { Self::ReqRes(e) } } impl From<mdns::Event> for Event { fn from(e: mdns::Event) -> Self { Self::Mdns(e) } } impl From<ping::Event> for Event { fn from(e: ping::Event) -> Self { Self::Ping(e) } } /* ================= STATE ================= */ struct PeerQuota { fuel: u64, window: Instant, } struct Replay { peer: PeerId, nonce: Vec<u8>, ts: Instant, } struct Reputation { strikes: u32, banned_until: Option<Instant>, } struct NodeState { engine: Engine, secret: StaticSecret, replay: VecDeque<Replay>, quota: HashMap<PeerId, PeerQuota>, reputation: HashMap<PeerId, Reputation>, limiter: Semaphore, } /* ================= NODE ================= */ pub struct ChimeraNode { swarm: Swarm<Behaviour>, state: Arc<RwLock<NodeState>>, } /* ================= INIT ================= */ impl ChimeraNode { pub async fn new(path: PathBuf) -> Result<Self> { let db = sled::open(path)?; let key = load_or_create_key(&db)?; let peer_id = PeerId::from(key.public()); let mut seed = [0u8; 32]; OsRng.fill_bytes(&mut seed); let secret = StaticSecret::from(seed); let mut cfg = Config::new(); cfg.consume_fuel(true); cfg.epoch_interruption(true); cfg.static_memory_maximum_size(32 * 1024 * 1024); let engine = Engine::new(&cfg)?; let behaviour = Behaviour { reqres: request_response::Behaviour::new( [(TaskProtocol(), ProtocolSupport::Full)], request_response::Config::default(), ), mdns: mdns::tokio::Behaviour::new(Default::default(), peer_id)?, ping: ping::Behaviour::new(ping::Config::new()), }; let transport = tcp::tokio::Transport::new(tcp::Config::default()) .upgrade(upgrade::Version::V1) .authenticate(noise::NoiseAuthenticated::xx(&key)?) .multiplex(yamux::Config::default()) .boxed(); let mut swarm = Swarm::with_tokio_executor(transport, behaviour, peer_id); swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?; let epoch_engine = engine.clone(); tokio::spawn(async move { loop { epoch_engine.increment_epoch(); tokio::time::sleep(Duration::from_millis(10)).await; } }); Ok(Self { swarm, state: Arc::new(RwLock::new(NodeState { engine, secret, replay: VecDeque::new(), quota: HashMap::new(), reputation: HashMap::new(), limiter: Semaphore::new(2), })), }) } pub async fn run(mut self) -> Result<()> { loop { if let SwarmEvent::Behaviour(Event::ReqRes( request_response::Event::Message { peer, message: request_response::Message::Request { request, channel, .. }, }, )) = self.swarm.select_next_some().await { let state = self.state.clone(); tokio::spawn(async move { let permit = state.read().await.limiter.clone().acquire().await; if permit.is_err() { return; } let res = timeout(TASK_TIMEOUT, handle_task(state, peer, request)) .await .unwrap_or_else(|_| Err(anyhow!("timeout"))) .unwrap_or_else(|e| TaskResult { task_id: vec![], result_json: format!("\"{}\"", e), exit_code: 1, }); let _ = channel.send(res); }); } } } } /* ================= EXEC ================= */ async fn handle_task( state: Arc<RwLock<NodeState>>, peer: PeerId, env: TaskEnvelope, ) -> Result<TaskResult> { let now = Instant::now(); /* reputation + replay */ { let mut s = state.write().await; if let Some(r) = s.reputation.get(&peer) { if r.banned_until.map(|t| t > now).unwrap_or(false) { return Err(anyhow!("banned")); } } s.replay.retain(|r| now.duration_since(r.ts) < REPLAY_TTL); if s.replay.iter().any(|r| r.peer == peer && r.nonce == env.nonce) { return Err(anyhow!("replay")); } if s.replay.len() >= REPLAY_MAX { s.replay.pop_front(); } s.replay.push_back(Replay { peer, nonce: env.nonce.clone(), ts: now, }); } /* verify signature */ let verifying = VerifyingKey::from_bytes(&env.sender_ed25519)?; let sig = Signature::from_bytes(&env.signature)?; let mut signed = Vec::new(); signed.extend(&env.task_id); signed.extend(&env.nonce); signed.extend(&env.encrypted_payload); verifying.verify(&Sha256::digest(&signed), &sig)?; /* decrypt */ let sender_pk = PublicKey::from(<[u8; 32]>::try_from(env.sender_x25519.as_slice())?); let shared = state.read().await.secret.diffie_hellman(&sender_pk); let mut key = [0u8; 32]; Hkdf::<Sha256>::new(None, shared.as_bytes()) .expand(b"chimera-task", &mut key)?; let decrypted = ChaCha20Poly1305::new(Key::from_slice(&key)) .decrypt(Nonce::from_slice(&env.nonce), env.encrypted_payload.as_ref())?; let payload = TaskPayload::decode(&*decrypted)?; /* quota */ let fuel = payload.max_fuel.min(MAX_FUEL as u32) as u64; { let mut s = state.write().await; let q = s.quota.entry(peer).or_insert(PeerQuota { fuel: 0, window: now, }); if now.duration_since(q.window) > Duration::from_secs(60) { q.fuel = 0; q.window = now; } if q.fuel + fuel > MAX_FUEL { let r = s.reputation.entry(peer).or_insert(Reputation { strikes: 0, banned_until: None, }); r.strikes += 1; if r.strikes >= BAN_AFTER { r.banned_until = Some(now + BAN_TIME); } return Err(anyhow!("fuel quota")); } q.fuel += fuel; } /* wasm */ let wasm = STANDARD.decode(payload.wasm_base64)?; if format!("{:x}", Sha256::digest(&wasm)) != payload.wasm_hash { return Err(anyhow!("hash")); } let engine = state.read().await.engine.clone(); let module = Module::new(&engine, wasm)?; let mut store = Store::new(&engine, ()); store.add_fuel(fuel)?; store.set_epoch_deadline(1); let instance = Instance::new(&mut store, &module, &[])?; let memory = instance.get_memory(&mut store, "memory").ok_or(anyhow!("no memory"))?; let alloc = instance.get_typed_func::<i32, i32>(&mut store, "allocate")?; let dealloc = instance.get_typed_func::<(i32, i32), ()>(&mut store, "deallocate")?; let main = instance.get_typed_func::<(i32, i32, i32, i32), i32>(&mut store, "main")?; let input = payload.args_json.as_bytes(); let in_ptr = alloc.call(&mut store, input.len() as i32)?; memory.write(&mut store, in_ptr as usize, input)?; let out_ptr_ptr = alloc.call(&mut store, 4)?; let out_len_ptr = alloc.call(&mut store, 4)?; if main.call(&mut store, (in_ptr, input.len() as i32, out_ptr_ptr, out_len_ptr))? != 0 { return Err(anyhow!("wasm")); } let mut buf = [0u8; 4]; memory.read(&store, out_len_ptr as usize, &mut buf)?; let len = i32::from_le_bytes(buf) as usize; if len > MAX_OUTPUT { return Err(anyhow!("output too large")); } memory.read(&store, out_ptr_ptr as usize, &mut buf)?; let ptr = i32::from_le_bytes(buf) as usize; let mut out = vec![0u8; len]; memory.read(&store, ptr, &mut out)?; dealloc.call(&mut store, (in_ptr, input.len() as i32))?; dealloc.call(&mut store, (out_ptr_ptr, 4))?; dealloc.call(&mut store, (out_len_ptr, 4))?; dealloc.call(&mut store, (ptr as i32, len as i32))?; Ok(TaskResult { task_id: env.task_id, result_json: String::from_utf8(out)?, exit_code: 0, }) } /* ================= CODEC ================= */ #[derive(Clone)] struct TaskProtocol; #[derive(Clone)] struct TaskCodec; impl request_response::ProtocolName for TaskProtocol { fn protocol_name(&self) -> &[u8] { b"/chimera/task/abi-final" } } impl request_response::Codec for TaskCodec { type Protocol = TaskProtocol; type Request = TaskEnvelope; type Response = TaskResult; async fn read_request<T>(&mut self, _: &TaskProtocol, io: &mut T) -> std::io::Result<Self::Request> where T: futures::AsyncRead + Unpin + Send { let mut buf = Vec::new(); io.read_to_end(&mut buf).await?; TaskEnvelope::decode(&*buf) .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e)) } async fn read_response<T>(&mut self, _: &TaskProtocol, io: &mut T) -> std::io::Result<Self::Response> where T: futures::AsyncRead + Unpin + Send { let mut buf = Vec::new(); io.read_to_end(&mut buf).await?; TaskResult::decode(&*buf) .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e)) } async fn write_request<T>(&mut self, _: &TaskProtocol, io: &mut T, r: Self::Request) -> std::io::Result<()> where T: futures::AsyncWrite + Unpin + Send { io.write_all(&r.encode_to_vec()).await } async fn write_response<T>(&mut self, _: &TaskProtocol, io: &mut T, r: Self::Response) -> std::io::Result<()> where T: futures::AsyncWrite + Unpin + Send { io.write_all(&r.encode_to_vec()).await } } /* ================= PERSIST ================= */ fn load_or_create_key(db: &Db) -> Result<Keypair> { let k = b"libp2p_key"; Ok(if let Some(v) = db.get(k)? { Keypair::from_protobuf(&v)? } else { let kp = Keypair::generate_ed25519(); db.insert(k, kp.to_protobuf())?; kp }) } /* ================= MAIN ================= */ #[tokio::main] async fn main() -> Result<()> { ChimeraNode::new(PathBuf::from("./chimera_db")).await?.run().await } 
