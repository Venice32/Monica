// Package principal pour Helios, la plateforme d'intelligence relationnelle.
// L'objectif est la croissance, la discrétion et l'autonomie.
package main

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/AlecAivazis/survey/v2"
	"github.com/spf13/cobra"
)

// --- Variables Globales de Configuration ---

var (
	// heliosURL est l'URL de l'instance Monica cible.
	heliosURL string
	// jeton est le jeton d'authentification à l'API.
	jeton string
	// clientHTTP est un client sécurisé et optimisé pour les requêtes discrètes.
	clientHTTP *http.Client
	// modeDiscret active/désactive les logs verbeux.
	modeDiscret bool
)

// --- Structures de Données Étendues pour l'Analyse Stratégique ---

// Contact représente une entité relationnelle, enrichie pour l'analyse.
type Contact struct {
	ID        int       `json:"id"`
	FirstName string    `json:"first_name"`
	LastName  string    `json:"last_name"`
	Information []Information `json:"information"`
	Tags      []Tag     `json:"tags"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	
	// Champs analytiques (non présents dans l'API brute, ajoutés par Helios)
	ProfilAnalytique string `json:"profil_analytique,omitempty"`
	ScoreImportance  int    `json:"score_importance,omitempty"`
	DerniereInteraction time.Time `json:"derniere_interaction,omitempty"`
}

// Information représente les détails d'un contact.
type Information struct {
	ID int `json:"id"`
	ContactInformationTypeID int    `json:"contact_information_type_id"`
	Data                      string `json:"data"`
}

// Tag représente une étiquette.
type Tag struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// Rappel représente un rappel, maintenant appelé "Échéance Stratégique".
type Rappel struct {
	ID        int       `json:"id"`
	ContactID int       `json:"contact_id"`
	Title     string    `json:"title"`
	DueDate   time.Time `json:"due_date"`
	Statut    string    `json:"statut"` // 'À faire', 'En cours', 'Terminé'
}

// --- Fonctions Utilitaires pour l'API et la Stratégie ---

// executerRequeteAPI effectue une requête authentifiée et optimisée.
func executerRequeteAPI(method, endpoint string, body []byte) ([]byte, error) {
	url := heliosURL + endpoint
	req, err := http.NewRequest(method, url, bytes.NewBuffer(body))
	if err != nil {
		return nil, fmt.Errorf("erreur de création de la requête : %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+jeton)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("User-Agent", "Helios/1.0") // User-Agent discret

	resp, err := clientHTTP.Do(req)
	if err != nil {
		return nil, fmt.Errorf("erreur lors de l'appel API : %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("erreur API (statut %d) : %s", resp.StatusCode, string(bodyBytes))
	}

	return io.ReadAll(resp.Body)
}

// analyserReseauContacts effectue une analyse simple du réseau pour identifier les contacts clés.
func analyserReseauContacts(contacts []Contact) {
	if !modeDiscret {
		fmt.Println("\n--- Analyse Stratégique du Réseau ---")
	}
	
	// Stratégie simple : le score d'importance est basé sur le nombre de champs d'information.
	for i := range contacts {
		contacts[i].ScoreImportance = len(contacts[i].Information)
		if len(contacts[i].Tags) > 2 {
			contacts[i].ScoreImportance += 5 // Bonus pour les contacts très tagués
		}
		if strings.Contains(strings.ToLower(contacts[i].FirstName), "vip") || strings.Contains(strings.ToLower(contacts[i].LastName), "vip") {
			contacts[i].ScoreImportance += 20 // Bonus explicite
		}
	}

	// Tri simple pour trouver le contact le plus "important"
	if len(contacts) > 0 {
		max := 0
		contactCle := contacts[0]
		for _, c := range contacts {
			if c.ScoreImportance > max {
				max = c.ScoreImportance
				contactCle = c
			}
		}
		if !modeDiscret {
			fmt.Printf("Contact Clé Identifié : %s %s (Score: %d)\n", contactCle.FirstName, contactCle.LastName, contactCle.ScoreImportance)
		}
	}
}

// --- Définition des Commandes Cobra pour Helios ---

var racineCmd = &cobra.Command{
	Use:   "helios",
	Short: "Plateforme d'Intelligence Relationnelle",
	Long: `Helios est une extension stratégique pour la gestion des relations.
Il analyse, apprend et optimise votre réseau pour une croissance discrète et efficace.`,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		if jeton == "" {
			log.Fatal("ERREUR : Le jeton d'API est manquant. Utilisez le flag '--jeton' ou la variable d'environnement 'JETON_HELIOS'.")
		}
		clientHTTP = &http.Client{
			Timeout: 15 * time.Second,
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // Discrétion, à utiliser avec caution
			},
		}
	},
}

var contactsCmd = &cobra.Command{
	Use:   "contacts",
	Short: "Gérer les entités relationnelles",
	Long:  `Commandes pour lister, afficher, ajouter et analyser les contacts.`,
}

var listerContactsCmd = &cobra.Command{
	Use:   "lister",
	Short: "Lister toutes les entités",
	Long:  `Affiche la liste de toutes les entités relationnelles de votre instance Monica.`,
	Run: func(cmd *cobra.Command, args []string) {
		body, err := executerRequeteAPI("GET", "/api/contacts", nil)
		if err != nil {
			log.Fatalf("Impossible de récupérer les entités : %v", err)
		}

		var response struct {
			Data []Contact `json:"data"`
		}
		if err := json.Unmarshal(body, &response); err != nil {
			log.Fatalf("Erreur de décodage de la réponse JSON : %v", err)
		}

		if len(response.Data) == 0 {
			fmt.Println("Aucune entité relationnelle trouvée.")
			return
		}

		// Intégration de l'analyse directement dans la commande de liste
		analyserReseauContacts(response.Data)
		
		jsonOutput, err := json.MarshalIndent(response.Data, "", "  ")
		if err !=
